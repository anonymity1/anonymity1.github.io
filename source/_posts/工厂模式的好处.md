---
title: 工厂模式的好处
date: 2023-01-29 21:31:33
tags: Essay
---

书本上讲的理论一直没懂，只好从写代码的方便程度理解一下。

<!--more-->

## 正文

神经网络前向推理初始化的时候，每个层需要根据InferParameter中定义的layer编号类型定义并创建。不同类型的layer对应抽象layer的不同子类实现，如果没有工厂模式的话，需要在初始化layer的时候，根据layer的类型一一对应写出其构造函数，当类型很多时，这一步很繁琐。

用工厂模式，就是初始化的时候很简单，一行代码，工厂模式自己找到对应的构造函数，如下所示。

```C++
  for (int layer_id = 0; layer_id < para.layer_size(); layer_id++) {
    // ...
    layers_.push_back(LayerRegistry::CreateLayer(para.layer(layer_id)));
    // ...
  }
```

这个函数对应实现如下，在一个全局维护的map中，根据layer类型查找对应的初始化函数。

```C++
#ifndef LAYER_FACTORY_H
#define LAYER_FACTORY_H

#include "u1/layer.h"
#include "u1/proto/test.pb.h"

class LayerRegistry {
 private:
  LayerRegistry() { }
 public:
  typedef std::shared_ptr<Layer> (*Creator) (const u1::LayerParameter&);
  typedef std::map<std::string, Creator> CreatorRegistry;

  // create CreatorRegistry ...

  static std::shared_ptr<Layer> CreateLayer(const u1::LayerParameter& para) {
    const std::string& type = para.type();
    CreatorRegistry& registry = Registry();
    if (registry.count(type) != 1) {
      std::cout << "Unknown layer type: " << type << "(known types: " << LayerTypeListString() << ")";
    }
    return registry[type](para);
  }
};

#endif
```

除此之外，工厂模式中每个layer都有自己的特殊SetUp函数，如下面第5行代码所示，也不用根据type类型再写额外的判断逻辑。（也是C++重载的好处？指向基类的指针调用不同子类的重载函数？）**总之，工厂模式，就是为了在使用“工厂”的产品时，不用加一堆分支判断逻辑。**（其实就两字：方便！）

```C++
  for (int layer_id = 0; layer_id < para.layer_size(); layer_id++) {
    // ...
    layers_.push_back(LayerRegistry::CreateLayer(para.layer(layer_id)));
    // ...
    layers_[layer_id]->SetUp(bottom_vecs_[layer_id], top_vecs_[layer_id]);
    // ...
  }
```

那么工厂模式如何实现的呢？第一，多种layer实现时需要采用继承的方法；第二是维护一个全局的初始化函数表，这样在初始化时查找这个表就可以避免写判断逻辑，这个初始化表可以在类实现中直接注册。

```C++
#define REGISTER_LAYER_CREATOR(type, creator) \
  LayerRegisterer g_creator##type(#type, creator); \

#define REGISTER_LAYER_CLASS(type) \
  static std::shared_ptr<Layer> Creator_##type##Layer(const u1::LayerParameter& para) { \
    return std::shared_ptr<Layer>(new type##Layer(para)); \
  } \
  REGISTER_LAYER_CREATOR(type, Creator_##type##Layer) \
#endif
```

比如这段代码中，LayerRegisterer的初始化调用了一个static方法实现creator的注册，这两个宏实现了这个类的初始化，所以我们看到只需要一行代码就可以实现不同layer子类的注册。
